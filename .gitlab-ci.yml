stages:
  - validate
  - attest
  - policy_check
  - change_request
  - approval
  - deploy

variables:
  OPA_URL: "http://mars.butterflycluster.com:8181/v1/data/pipeline/allow"
  SERVICENOW_URL: "https://$SERVICENOW_INSTANCE.service-now.com/api/now/table/change_request"
  VAULT_ADDR: "https://phobos.butterflycluster.com:8200"
  VAULT_SKIP_VERIFY: "true"  # Set to "false" when using a valid TLS cert
  GIT_STRATEGY: clone

mock-validate-jira:
  stage: validate
  script: |
    echo '{ "ticket": "DASH-123", "status": "Open", "type": "Story" }' > validated_issues.json
    echo '{ "validated_jira": true, "has_high_severity": false, "license_compliant": true }' > opa_input.json
  artifacts:
    paths:
      - validated_issues.json
      - opa_input.json

attest-validation:
  stage: attest
  image: python:3.10
  before_script:
    - apt-get update && apt-get install -y curl jq unzip
    - python3 -m venv venv
    - ./venv/bin/pip install --upgrade pip
    - ./venv/bin/pip install "in-toto[cli]" securesystemslib

    # 🔍 Debug Vault env variables
    - echo "🔧 VAULT_ADDR=$VAULT_ADDR"
    - echo "🔧 VAULT_SKIP_VERIFY=$VAULT_SKIP_VERIFY"
    - echo "🔧 VAULT_TOKEN is ${#VAULT_TOKEN} characters long"

    # 🔐 Fetch private key from Vault
    - |
      echo "🔐 Retrieving signing key from Vault..."
      VAULT_KEY=$(curl -k --fail -sS \
        --header "X-Vault-Token: $VAULT_TOKEN" \
        "$VAULT_ADDR/v1/secret/data/in-toto/key") || {
          echo "❌ ERROR: Vault request failed. Check token, address, or Vault policies."
          exit 1
        }

      echo "$VAULT_KEY" | jq -r '.data.data.private_key' > private.pem

      if [ ! -s private.pem ]; then
        echo "❌ ERROR: Vault response did not contain a valid 'private_key'."
        echo "$VAULT_KEY" | jq .
        exit 1
      fi

      echo "✅ Key saved to private.pem"
  script: |
    echo "🔏 Creating in-toto attestation with Python..."
    ./venv/bin/python3 -c "
    import json
    from in_toto.models.link import Link
    from securesystemslib.keys import import_ed25519_privatekey_from_pem
    
    # Load the private key from Vault
    key = import_ed25519_privatekey_from_pem('private.pem', password=None)
    
    # Simulate a link (real in-toto-run behavior would capture commands)
    link = Link(name='validate-jira', products=['validated_issues.json', 'opa_input.json'])
    
    # Sign the link
    link.sign(key)
    
    # Save as validate-jira.link
    link.dump('validate-jira.link')
    "

  artifacts:
    paths:
      - validate-jira.link

policy-check:
  stage: policy_check
  script: |
    curl -s -X POST -H "Content-Type: application/json" -d @opa_input.json $OPA_URL > opa_result.json
    cat opa_result.json
    jq '.result.allow' opa_result.json | grep true || exit 1
  artifacts:
    paths:
      - opa_result.json

request-cr:
  stage: change_request
  script: |
    curl -s -X POST "$SERVICENOW_URL" \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $SERVICENOW_TOKEN" \
      -d @opa_input.json > cr_response.json
  artifacts:
    paths:
      - cr_response.json

manual-approval:
  stage: approval
  script: |
    echo "Manual approval step, use GitLab UI"
  when: manual
  allow_failure: false

deploy:
  stage: deploy
  script: |
    echo '{ "status": "success", "timestamp": "'$(date)'" }' > deployment_metadata.json
  artifacts:
    paths:
      - deployment_metadata.json
